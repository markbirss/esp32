#!/bin/ruby

# Tom Trebisky  5-12-2018

# Anyone who realizes what is being done here will be appalled.
# I am launching a process to run objdump for EACH and EVERY line
# that needs to be disassembled.  Too bad.
# If you don't like it, write your own disassembler !!  :-)
# This is a "get 'er done" approach and enabled me to get most
# of this written in an evening.
#
# It takes just under 20 seconds now, with two passes,
#  on my 3.5 Ghz x86_64 system,
# and anway, that computer has nothing better to do.

# I have discovered that rom1 follows after rom0 at
# addresses 0x40060000 to 0x4006ffff
# So we actually have 7 * 64k of ROM to deal with.
#    458752 bytes

# After chasing the thread of execution that begins at
# 0x40000400, we have disassembled 19234 bytes of 458752
# (approximately 4 percent!)

# TODO:
# 0 - implement Map class and cleanup
# 0.1 finish .hex and .xhex cleanup
# 1 - find out why my "Twice" messages don't run in a continuous
#       flow thru areas where I am sure they must.  DONE
#  Things involving setting ruby subarrays that I still don't understand.
# 2 - deal with l32r nicely. DONE
# 3 - generate an output in proper order via pass2. DONE
# 4 - dump the "gaps" in some nice way.
# 5 - symbols from ld file
# 6 - strings
# 7 - add call table and generate "sub_xxx" sort of labels
#     for all call targets not in the ld file.
# 8 arrange for hints file

$bin_file = "esp32.bin"
$elf_file = "esp32.elf"

$rom_base = 0x40000000
$rom_size = 65536 * 7

$hintfile = "hints"

# Augment this with some convenience methods
class Integer
    def hex
	"%08x" % self
    end
    def xhex
	"0x%08x" % self
    end
end

def error ( a, s )
    puts "Trouble at " + a.xhex
    puts s
    exit
end


# Information for a single instruction
class Instr
    attr_reader :addr
    attr_reader :line
    attr_reader :size
    attr_reader :target
    attr_reader :is_branch
    attr_reader :is_call
    attr_reader :is_jump
    attr_reader :is_l32r
    attr_reader :is_term

    def initialize ( addr, stuff )
	@is_branch = false
	@is_call = false
	@is_jump = false
	@is_l32r = false
	@is_term = false
	@target = nil

	@addr = addr

	info = stuff.split "\n"
#	puts stuff
#	puts info.size
	line = nil
	match = Regexp.new "^" + addr.hex + ":"
	info.each { |l|
	    line = l if match =~ l
	}

	error addr, stuff unless line

	@line = line
	w = line.split
	if w.size < 3
	    error addr, stuff
	end
	@size = w[1].size / 2
	if @size < 1 or @size > 3
	    error addr, stuff
	end
	op = w[2]
	@is_term = true if op =~ /^ret/
	@is_term = true if op =~ /^j/
	@is_jump = true if op =~ /^j/
	@is_jump = false if op =~ /^jx/
	@is_branch = true if op =~ /^loopnez/
	@is_branch = true if op =~ /^b/
	@is_branch = false if op =~ /^break/
	@is_call = true if op =~ /^call/
	@is_call = false if op =~ /^callx/
	@is_l32r = true if op =~ /^l32r/
	if @is_jump
	    #puts "Jump to #{w[3]}"
	    @target = w[-1]
	end
	if @is_call
	    @target = w[-1]
	end
	if @is_branch
	    @target = w[-1]
	end
	if @is_l32r
	    @target = w[-1]
	end
    end
end

class Map
    def initialize
	@map = Array.new size, "X"
	if File.exist? $hintfile
	    f = File.open $hintfile
	    f.each { |l|
		puts "Hint: " + l
	    }
	    close f
	end
	# after Call to 0x40000704 we will never return from.
	# XXX belongs in hints file
	@map[0x55d] = "D"
    end
end

class Dumper
    def Dumper.map ( size )
	map = Array.new size, "X"
	if File.exist? $hintfile
	    f = File.open $hintfile
	    f.each { |l|
		puts "Hint: " + l
	    }
	    close f
	end
	# after Call to 0x40000704 we will never return from.
	# XXX belongs in hints file
	map[0x55d] = "D"
	return map
    end
    def initialize
	@elf = $elf_file
	@size = $rom_size
	@base = $rom_base

	@show_pass1 = false
	@debug_pass1 = false

	# We need this to fetch stuff for l32r cleanup
	file = File.open $bin_file, "rb"
	@binary = file.read
	file.close
	if @binary.size != $rom_size
	    puts "Something is wrong with binary file"
	    exit
	end

	@limit = @base + @size -1
	# This should be on the search path, if not prefix
	# with something like /opt/esp32/xtensa-esp32-elf/bin
#	@cmd = "xtensa-lx106-elf-objdump -mxtensa -d -z"
	@cmd = "xtensa-esp32-elf-objdump -mxtensa -d -z"
	@cur_addr = Array.new
	@old_addr = Array.new
	@map = Dumper.map $rom_size
    end
    def one_inst ( addr )
#        $(OBJDUMP) --start-address=0x40000000 --stop-address=0x400003ff rom0.elf >zzz.dis
	eaddr = addr + 3
	range = "--start-address=#{addr.xhex} --stop-address=#{eaddr.xhex}"
	cmd = @cmd + " " + range + " #{@elf}"
#	puts cmd
	return Instr.new addr, `#{cmd}`
    end
    def add_addr ( target )
	#puts "Check add: " + target
	error 0xdead, target if target !~ /^0x4/
	addr = target.hex
	#puts "Maybe add: " + addr.hex
	# Never see Wow, now that we have all 7 * 64k
	if addr > @limit
	    puts "Wow, skipping: " + addr.hex
	    return
	end
	return if @new_addr.include? addr
	return if @old_addr.include? addr
	puts "Add: " + addr.hex if @debug_pass1
	@new_addr << addr
    end

    def claim ( index, size, type )
	size.times {
	    @map[index] = type
	    index += 1
	}
    end
    def fetch_long ( index )
	bytes = @binary[index,4]
	vals = bytes.unpack "L"
	val = vals[0]
    end

    def get_l32r ( addr )
	val = fetch_long addr - @base
	return val.xhex
    end

    def print_inst ( i )
	    if i.is_l32r
		val = get_l32r ( i.target.hex )
		puts i.line + "\t; ( " + val + " )"
	    else
		puts i.line
	    end
    end

    def range1 ( addr )
	loop {
	    index = addr - @base
	    break unless @map[index] == "X"

	    i = one_inst addr

	    print_inst i if @show_pass1

	    if i.is_l32r
		claim (i.target.hex - @base), 4, "L"
	    end

	    index = addr - @base

	    # This indicates we have "slid" into a section we
	    # already disassembled, usually because we followed a
	    # branch prior to that section, so we can justend.
	    if @map[index] == "I"
		# puts "Twice visiting: " + addr.hex
		puts "*** END (Twice) ***" if @debug_pass1
		break
	    end

	    claim index, i.size, "I"

	    add_addr i.target if i.is_jump
	    add_addr i.target if i.is_branch
	    add_addr i.target if i.is_call
	    addr += i.size
	    if i.is_term
		puts "*** END ***" if @debug_pass1
		break
	    end
	    i = nil	# help garbage collection ??
	}
    end
    def pass1 ( addr )
	@cur_addr << addr
	pass = 0
	loop {
	    pass += 1
	    break if @cur_addr.size < 1
	    puts "Starting pass for %d items" % @cur_addr.size if @debug_pass1
	    @new_addr = Array.new
	    loop {
		t = @cur_addr.shift
		break unless t
		@old_addr << t
		next if @map[t-@base] != "X"
		puts "Chase: " + t.hex + " (#{@cur_addr.size})" if @debug_pass1
		range1 t
	    }
	    puts "!!! Pass #{pass} finished, %d waiting" % @new_addr.size if @debug_pass1

	    # We drop things that we had branches to, but were
	    # in the range we continued to disassemble.
	    @new_addr.each { |n|
		if @map[n-@base] != "X"
		    puts "Dropping: " + n.hex if @debug_pass1
		    next
		end
		@cur_addr << n
	    }
	}
    end

    # The game here is to collect contiguous blocks of the same type
    def get_range ( index )
	if index >= @size
	    return "Q", 0
	end
	if @map[index] == "L"
	    return "L", index + 4
	end
	t = @map[index]
	loop {
	    index = index + 1
	    break if index >= @size
	    break if @map[index] != t
	}
	return t, index
    end

    # Just display, following a linear thread of execution
    # until it terminates.
    def range2 ( addr )
	loop {
	    # This test avoids runon disassembly that
	    # goes outside of regions already delimited
	    # in pass 1. Now sort of belt and suspenders,
	    # but we have seen it happen in cases where
	    # only a hint would set things right.
	    index = addr - @base
	    if @map[index] != "I" and @map[index] != "X"
		break
	    end
	    i = one_inst addr
	    print_inst i
	    puts "" if i.is_term

	    addr += i.size
	    if i.is_term
		# puts "*** END2 ***"
		break
	    end
	    i = nil	# help garbage collection ??
	}
	return addr
    end
    def pass2
	index = 0
	loop {
	    type, nxt = get_range index
	    break if type == "Q"
	    addr = @base + index
	    xaddr = @base + nxt
	    eaddr = xaddr - 1
	    
	    #puts "Pass2 #{addr.hex} #{xaddr.hex} #{type}"

	    # Handle a l32r
	    if type == "L"
		hval = fetch_long(index).hex
		print "#{addr.hex}:	" + hval + "	; l32r\n"
	    elsif type == "I"
		loop {
		    naddr = range2 addr
		    #puts "Range2 #{addr.hex} #{naddr.hex}"
		    break if naddr >= xaddr
		    #print "I ended prematurely: #{naddr.hex} #{xaddr.hex}\n"

		    addr = naddr
		}
	    else
		print "#{addr.hex} to #{eaddr.hex}  --------- Unknown territory !!!\n"
	    end
	    index = nxt
	}
    end
    def show_map
	addr = @base
	i = 0
	loop {
	    break unless @map[i]
	    print "MAP #{addr.hex}: "
	    16.times {
		print " " + @map[i] 
		i += 1
	    }
	    print "\n"
	    addr += 16
	}
    end
    def summary
	count = 0;
	@map.each { |m|
	    count += 1 if m != "X"
	}
	puts "; disassembled #{count} bytes of #{@size}"
    end
end

d = Dumper.new
#d.show_map
#exit

d.pass1 0x40000400
puts "End of Pass 1"
#d.show_map
d.pass2
d.summary

#puts "DONE"

# THE END

